
> 这里不讨论 v8 内部的实现方式。

```ts
const arr = [1, 35, 12, 151, 12, 1, 2, 1, 1, 15, 2, 123, 33, 1252, 36, 326]

arr.sort((a, b) => a - b)

console.log(arr)

// 结果顺序从小到大
```

`sort` 排序，按照使用说明的描述，可以很快完成数字小到大，或大到小。

但若是用来分层顺序呢？

## 分层

这里先只记录分 2 层，使 数据分成 2 部分，但原始的顺序不能变。

> 这里的使用场景为，数据按照之前需要排好序了，但需要对条件在一部优先级排序。

这种顺序很容易使用分离数组再拼接，遍历一遍便可完成。但是 `sort` 代码量更少省事。

### 结论

这里如果查看 MDN 的 compareFn 说明的话，容易理解混乱。所以直接上代码结论:

```ts
const arr = [1, 35, 12, 'a', 151, 12, 1, 2, 1, 'b', 'c', 'd']

arr.sort((b, a) => {
	return typeof a === 'string' && typeof b === 'number' ? -1 : 0
})

console.log(arr)

// [ 1, 35, 12, 151, 12, 1, 2, 1,  'a', 'b', 'c', 'd']
```

这里希望实现的是：number 在前，string 在后，原有顺序不变。这里需要注意的点：

- compareFn 返回 -1 才表示 a,b 更换顺序
- compareFn(b,a => number) , 这里反转了 a,b 顺序。
  - 因为这里理解原本数组是: [a, b, c, d] 的话，(b,a) => number 这样反过来传递才是跟理解相同
- 返回 1 和 0 都会不改变顺序，但 1 代表是： _每个元素都被认为应该排在其他元素之后_ 。
  - 所以，为了代码和意义统一，返回 0 更好。
